# -*- coding: utf-8 -*-
"""app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19NxMAROWASwU4oCiHFC7q9m7EYdTzFBJ
"""

import streamlit as st
import os
import tempfile
import subprocess
from moviepy.editor import VideoFileClip
from pydub import AudioSegment
import torch
from transformers import Wav2Vec2ForSequenceClassification, Wav2Vec2Processor

MODEL_ID = "s3prl/s3prl-voice-type-classifier-apc"
LABELS = ["american", "british", "australian", "indian", "others"]  # example

@st.cache_resource
def load_model():
    processor = Wav2Vec2Processor.from_pretrained(MODEL_ID)
    model = Wav2Vec2ForSequenceClassification.from_pretrained(MODEL_ID)
    return processor, model

def validate_mp4(file_path):
    try:
        result = subprocess.run(
            ['ffmpeg', '-v', 'error', '-i', file_path, '-f', 'null', '-'],
            stderr=subprocess.PIPE, stdout=subprocess.PIPE
        )
        return result.returncode == 0
    except Exception as e:
        st.error(f"Validation failed: {e}")
        return False

def repair_mp4(input_path, output_path):
    try:
        subprocess.run(
            ['ffmpeg', '-i', input_path, '-c', 'copy', '-movflags', 'faststart', output_path],
            check=True
        )
        return True
    except subprocess.CalledProcessError:
        return False

def extract_audio_from_video(video_path):
    try:
        clip = VideoFileClip(video_path)
        temp_audio = tempfile.NamedTemporaryFile(suffix=".wav", delete=False)
        clip.audio.write_audiofile(temp_audio.name, codec='pcm_s16le')
        return temp_audio.name
    except Exception as e:
        st.error(f"‚ùå Failed to extract audio: {e}")
        return None

def detect_accent(audio_path, processor, model):
    audio = AudioSegment.from_wav(audio_path).set_channels(1).set_frame_rate(16000)
    samples = audio.get_array_of_samples()
    inputs = processor(samples, sampling_rate=16000, return_tensors="pt", padding=True)
    with torch.no_grad():
        logits = model(**inputs).logits
        predicted_class = logits.argmax().item()
    return LABELS[predicted_class], torch.nn.functional.softmax(logits, dim=1)[0][predicted_class].item()

def main():
    st.title("üéôÔ∏è English Accent Detection App")

    uploaded_file = st.file_uploader("Upload a video (MP4 format)", type=["mp4"])

    if uploaded_file:
        with tempfile.NamedTemporaryFile(delete=False, suffix=".mp4") as tmp_file:
            tmp_file.write(uploaded_file.read())
            tmp_file_path = tmp_file.name

        # Validate and optionally repair the video
        if not validate_mp4(tmp_file_path):
            st.warning("‚ö†Ô∏è Video is missing metadata. Attempting repair...")
            repaired_path = tmp_file_path + "_repaired.mp4"
            if not repair_mp4(tmp_file_path, repaired_path):
                st.error("‚ùå Failed to repair video. Please upload a different file.")
                return
            tmp_file_path = repaired_path

        # Extract audio
        audio_path = extract_audio_from_video(tmp_file_path)
        if not audio_path:
            return

        # Load model and detect accent
        processor, model = load_model()
        with st.spinner("Detecting accent..."):
            accent, confidence = detect_accent(audio_path, processor, model)
            st.success(f"üåç Detected Accent: **{accent.title()}** with **{confidence:.2%}** confidence")

        os.remove(audio_path)
        os.remove(tmp_file_path)

if __name__ == "__main__":
    main()